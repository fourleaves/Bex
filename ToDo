1.完善cobwebs, 先做好设计再编码!
    先画业务流程图，再画用例图，再画活动图，再画逻辑视图（比如分层的对象图），再画包图或组件图，
  最后才到类图这个过程是一个逐步求精的过程先给非程序员展示的一般是对象图，好理解;
  给程序员展示包图或者组件图，从高层上看，好理解, 只有到了详细实现的时候才需要类图.
    对应的是UP过程中的，业务分析建模、用例分析建模、系统分析建模.

2.重写type_name.hpp, 实现完完整整的输出类型的真实名字.
    思路: 第一步, 编译期逐层解析类型外壳, 将其转换为一个mpl容器存储的类型树
          第二部, 将类型树在运行期拼接为可以显示的字符串.

    A): 可以直接获取名字的类型:
        1.内置类型
        2.用户自定义类型class union struct
        3.decltype推导得到的某些类型(比如nullptr_t)
    B): 类型修饰:
        *, &, &&, [], [N], const, volatile
        (注意避免cv限定符的传递性导致错误的名字)
    C): 类型复合:
        1.自由函数
        2.成员函数
        3.成员变量
        4.模板类参数
        5.模板类的模板参数

    如: R(T const, U (&)[2][3])
        生成树:     R       T       U
                    |       |       |
                    |       | + c   | + [3]
                    |       |       |
                    |     T const   U[3]
                    |       |       |
                    |       |       | + [2]
                    |       |       |
                    |       |       U[2][3]
                    |       |       |
                    |       |       | + &
                    |       |       |
                    |       |       U (&)[2][3]
                    |       |       |
                     \      |      /
                      \     |     /
                       \    |    / + 自由函数复合器
                        \   |   /
                         \  |  /
                          \ | /
                    R(T const, U (&)[2][3])

        树中的每个结点和结点之间的运算, 都用一个类型来表示.
