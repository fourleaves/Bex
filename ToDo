1.实现模板元编程组件: mpl_while
    template < template<typename> Cond, template<typename> Do, typename T>
    struct mpl_while;

2.重写type_name.hpp, 实现完完整整的输出类型的真实名字.
    思路: 第一步, 编译期逐层解析类型外壳, 将其转换为一个mpl容器存储的类型树
          第二部, 将类型树在运行期拼接为可以显示的字符串.

    A): 可以直接获取名字的类型:
        1.内置类型
        2.用户自定义类型class union struct
        3.decltype推导得到的某些类型(比如nullptr_t)
    B): 类型修饰:
        *, &, &&, [], [N], const, volatile
        (注意避免cv限定符的传递性导致错误的名字)
    C): 类型复合:
        1.自由函数
        2.成员函数
        3.成员变量
        4.模板类参数
        5.模板类的模板参数

    如: R(T const, U (&)[2][3])
        生成树:     R       T       U
                    |       |       |
                    |       | + c   | + [3]
                    |       |       |
                    |     T const   U[3]
                    |       |       |
                    |       |       | + [2]
                    |       |       |
                    |       |       U[2][3]
                    |       |       |
                    |       |       | + &
                    |       |       |
                    |       |       U (&)[2][3]
                    |       |       |
                     \      |      /
                      \     |     /
                       \    |    / + 自由函数复合器
                        \   |   /
                         \  |  /
                          \ | /
                    R(T const, U (&)[2][3])

        树中的每个结点和结点之间的运算, 都用一个类型来表示.
